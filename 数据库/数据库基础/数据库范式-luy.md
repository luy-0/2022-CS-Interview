# 数据库范式

## 理解范式

范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”

如何理解这句话? 在设计一个数据库系统时，我们实际上时在设计不同实体之间的**关系**。那么设计关系时所循行的标准，称为范式。具体有哪些标准呢？我们一般将数据库范式分为1NF，2NF，3NF，BCNF，4NF，5NF。这代表着不同级别的设计标准。符合高一级别的范式，必定符合第一级别的范式。



## 前置知识

【前置知识部分来自掘金用户@奋斗的小皇帝，有删改，链接见文末】

在学习数据库范式之前，我们必须了解一些前置知识，这些知识在后续的内容将会大量使用，如果对这些不了解，那么将会对后面的内容一头雾水。

首先，我们定义一张表，并添加一些数据，这个表 1 （选课表）有助于我们理解这些概念：



![img](https://user-gold-cdn.xitu.io/2020/6/8/172944729191ddd4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



### 码

关系中的某个或者某几个属性的集合，用于唯一地标识每一条数据（这里的每一条数据就是数据库中的每一条记录）。

> 请注意：码可以是一个或多个属性，一个表中可能存在多个码。例如，{学号，选课}这两个属性组成的码可以唯一地确定数据库的条项。

#### 候选码

在一个表的关系中，可以存在多个关系集合用于唯一确定一条记录，这些多个集合就称为**候选码**，也称为候选键。候选码可以存在多个，每一个候选码都可以唯一地确定一条记录。

我们换一种更加严谨的说法：假设 K 为某个表中的一个属性或者属性组，如果除去 K 之外的所有属性都**完全函数依赖**（稍后会介绍）于 K，那么我们就称 K 为候选码。

根据上表的示例我们可以得出一个候选码：

- （学号，课名）

#### 主码

通常我们会从候选码中选择一个码作为**主码**，也就是我们通常所说的主键。

### 函数依赖

在数学上的解释是：`y = f(x)`，输入一个 X，可以得到一个确定的 Y。

对应到一个表上就是，在属性X 确定的情况下，必定能够确定某个属性 Y 的值，这就能够称作 Y 函数依赖于 X，写作 X -> Y 。

> 注意：X未必是一个属性，也可能是属性集合。

记作：



![img](https://user-gold-cdn.xitu.io/2020/6/8/17294478f4b78bd9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



比如下面这些关系都**存在**函数依赖：

- （学号）->（姓名）
- （学号，课名）->（分数）
- （系名）->（系主任）

但是，下面这些关系就**不存在**函数依赖：

- （姓名）->（学号），因为有可能会出现重名的情况，所以只依靠姓名是无法确定学号的。
- （学号）->（分数），因为一个学号有多个科目，每一个科目都存在一个分数，不能只靠学号来确定分数。
- ……

#### 完全函数依赖

在一个表中，如果存在 X -> Y，那么对于 X 下的任何一个真子集（X’），X’ -> Y都不成立，那么我们就说 Y 对于 X 完成函数依赖。

> 如果X可以唯一确定Y，并且找不到X中的更少的属性可以唯一确定Y，那么称之为完全函数依赖。

记作：X ->F  Y



![img](https://user-gold-cdn.xitu.io/2020/6/8/1729447d6caba0f9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



通俗的说，必须通过码中的所有属性才可以唯一确定一个值。比如：

- （学号）->F（姓名）
- （学号，课名）->F（分数）

#### 部分函数依赖

在一个表中，如果存在 X -> Y，但是 Y 并不完成依赖于 X。存在一些 X 的子集 X’，X‘ -> Y成立，那么我们就说 Y 对于X 部分函数依赖。

记作：X ->P Y



![img](https://user-gold-cdn.xitu.io/2020/6/8/17294481094df130?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



通俗的说，只需要码中的部分属性即可唯一确定一个值。比如：

- （学号，课名）-> （姓名），只需要根据码中的学号即可唯一确定姓名。

**它跟完全函数依赖的区别在于，完全函数依赖必须要通过码中的所有属性才可以唯一确定一个值，而部分函数依赖只需要码中的部分属性即可。**

#### 传递函数依赖

如果 Z 函数依赖于 Y，Y 函数依赖于 X，并且 X 不函数依赖于 Y，那么我们就说 Z 传递函数依赖于 X。

记作：X ->T Z



![img](https://user-gold-cdn.xitu.io/2020/6/8/17294484b7bd7b14?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



通俗的说，通过码可以唯一确定一个属性，然后通过该属性可以唯一确定另一个属性，所以就演变为了可以通过码唯一确定一个无函数依赖的属性。

### 属性

属性就是我们在表中定义的每一个列。

#### 主属性

在码中的所有属性（每一列）都称为主属性

#### 非主属性

除了主属性之外的其他属性，都称为非主属性。




## 范式标准

### 1NF

1NF的定义为：符合1NF的关系中的**每个属性都不可再分**。

何谓属性不能再分？ 举例：你可以把`数量` 、`单价`分别作为两个属性设计，这是符合范式的。如果你设计了`进货`这一属性，并且将`数量` 、`单价`作为两个子属性设计，这不符合范式。事实上这个例子应该是列族数据库。（一种NoSQL）

**1NF是所有关系型数据库的最基本要求**，你在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。

但是其实也不一定如此。例如，`地址`属性中的值可以是“陕西省西安市长安区西安电子科技大学”， 也可以分别设置多个属性：`省份`、`城市`、`区县`、`详细地址`。`地址`属性理论上是可以再分的，但实际生产中也可以使用。当然，从数据库设计的角度肯定是设置成多个属性更佳。

![1NF](https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/1NF.jpg)

即便满足1NF，数据库还可能会出现以下问题：

1. 数据冗余

   每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次

2. 插入异常

   假如学校新建了一个系，但是暂时还没有招收任何学生，那么是无法将系名与系主任的数据单独地添加到数据表中去。

3. 删除异常

   假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。

4. 修改异常

   假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据

### 2NF

**2NF 在 1NF 的基础上，消除了非主属性对码的部分函数依赖** 。

> **码**是可以唯一确定一条记录的属性集合；
>
> **非主属性**是除了码中属性之外的其他属性。
>
> 部分函数依赖：只需要码中的部分属性即可唯一确定一个值。

判断是否符合 2NF 可以通过以下步骤：

1. 找出表中所有的**码（候选码）**。
2. 根据第一步得出的码找出所有的**主属性**。
3. 除了主属性之外的其他属性，就都是**非主属性**。
4. 判断是否存在非主属性**部分函数依赖**于码。

例如上例中：

1. 候选码包括：{学号，课程}

2. 主属性：学号、课程

3. 非主属性：姓名、系名、系主任、分数

4. 依次考察这些非主属性：

   1. 姓名：有 学号->姓名，部分函数依赖

   2. 系名：有 学号->系名，部分函数依赖

   3. 系主任：有 学号->系主任，部分函数依赖

      > 注：显然，系主任也可以被系名唯一确定；这其实是第三范式的问题，我们稍后讨论。
      >
      > 在此处，系主任也是可以被学号唯一确定的。

   4. 分数：只有 {学号，课程}->分数，完全函数依赖

在上面这张表中，我们发现 **非主属性** 中只有`分数`这一项完全依赖的。因此我们可以将表拆为两张。

![2NF1](https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/2NF1.webp)

![2NF2](https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/2NF2.webp)

再次检查，不难看出学生表也是2NF 的。



在2NF中，我们可以解决1NF的两个问题：数据冗余和修改异常。这主要是将1NF中的重复的数据单独拎出来建表。但对于另外两个问题，2NF依旧存在：

1. 插入异常

   假如学校新建了一个系，但是暂时还没有招收任何学生，那么是无法将系名与系主任的数据单独地添加到数据表中去。

2. 删除异常

   假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。



### 3NF

3NF在 2NF 的基础上，消除非主属性对码的**传递函数依赖**。

> **码**是可以唯一确定一条记录的属性集合；
>
> **非主属性**是除了码中属性之外的其他属性。
>
> **传递函数依赖** 如果 Z 函数依赖于 Y，Y 函数依赖于 X，并且 X 不函数依赖于 Y，那么我们就说 Z 传递函数依赖于 X。

还记得我们在1NF埋下的一个点吗？系名可以由学号唯一确定，系主任也可以由学号唯一确定，可是我们总觉得有那里不对。更优雅的方式应该是：学号决定系名，而系名决定系主任。这里的关键点在于 **传递函数依赖**，事实上，当出现传递函数依赖的时候，我们可以将这一依赖涉及到的属性们再单独拉个表出来。

![3NF2](https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/3NF2.webp)

![3NF1](https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/3NF1.webp)



到此为止，我们已经解决了数据冗余、插入异常、删除异常、修改异常。这份数据库也算得上设计恰当了。



### BCNF

BCNF： 不存在**主属性**对于码的部分函数依赖和传递函数依赖。

注意哈，我们这里讲的是主属性，而先前的几个范式都是针对的非主属性。

如果数据库满足第三范式，那么它一定满足第二范式。

如果满足BCNF，它一定满足第二、第三范式。

先前的几个例子中，我们由于最开始的设计规避掉了对BCNF的讨论。下面来看另一个例子。

- 某公司有若干个仓库
- 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作
- 一个仓库中可以存放多种物品，一个物品也可以存放在不同的仓库。每种物品在每个仓库中都有对应的数量。

![BCFN1](https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/BCFN%201.webp)



我们来分析一下这个表：

- 码：（仓库名，物品名），（管理员，物品名）
- 主属性：仓库名、物品名、管理员
- 非主属性：数量

非主属性只有“数量”，而非主属性对于两个码都不存在部分函数依赖和传递函数依赖，所以这个表是符合 3NF的。但是这个表却是不符合 BCNF 的。

因为存在主属性对码的部分函数依赖：

- （仓库名，物品名）-> 管理员，只要确定仓库名，即可确定管理员，所以管理员部分函数依赖于仓库名。
- （管理员，物品名）-> 仓库名，同上。

那么我们要将该表进行拆分才能让物品表符合 BCNF。将该表拆分为两个表：仓库表、物品表。(注: 也可以拆分为两个表: 管理员-物品-数量表与仓库-管理员表)

![BCNF1](https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/BCNF2.webp)

![BCNF3](https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/19/BCNF3.webp)

我们可以来看看拆分之后解决了什么问题：

- 如果仓库换管理员，不需要将物品表中的每一个该仓库的数据都进行修改。
- 如果物品都被删除，仓库依然存在，仓库管理员也依然于仓库存在关系
- 如果新增一个仓库，但是还没有物品，可以直接在仓库表添加一条记录即可，数据库不会出错。

所以消除了主属性对码的部分函数依赖和传递函数依赖之后，数据库中的操作的异常就不再出现了。

结论：**在 3NF 的基础上，消除主属性对码的部分函数依赖和传递函数依赖。**



## 参考资料

[如何理解关系型数据库的常见设计范式？ - 刘慰的回答 - 知乎](https://www.zhihu.com/question/24696366/answer/29189700)

[数据库设计的基础——数据库范式](https://juejin.im/post/6844904183611523086#heading-20)

[Database normalization](https://en.wikipedia.org/wiki/Database_normalization)