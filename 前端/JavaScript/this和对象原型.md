# this和对象原型

## this究竟是什么

### 常见误解

* this并不是对函数本身的调用
* 它的作用域，this并不是一直只想函数的作用域

### 正确概念

在运行时进行绑定，上下文取决于函数调用的各种条件，和函数声明位置没有任何关系，只取决于函数的调用方式。
通过函数的调用栈来确定this的具体指向，和哪个作用域/变量等进行绑定

## this的绑定

### 默认绑定

在直接外部调用的时候，this时全局

### 隐式绑定

默认上一级
但是隐式经常会导致**隐式丢失**

### 显示绑定

使用call（），apply（）方法
foo.call(obj) 显式声明，foo中的this为obj
//从this绑定的角度来说，call和apply是一样的
当传入一个基础类型的时候，原始值会被转换成对应的对象形式

#### 硬绑定

在函数内部使用显示绑定，使得每次调用都会执行绑定，从而不会改变绑定的值
创建一个可以重复使用的辅助函数
（提供对函数进行硬绑定的函数，然后将他进行再次调用新生成一个函数）
同时，ES5也提供了应变吗的心函数，会将制定的参数设置为this的上下文并调用原始函数
```foo.bind(obj)```
创建一个新的包装函数，忽略当前的this绑定，并把提供的对象绑定到this上
使用硬绑定之后，无法使用饮食或显示绑定修改this的能力

#### API调用的上下文

forEach

### new 绑定

#### new的执行过程

* 创建一个全新的对象
* 这个新的对象执行原型连接
* 这个新对象会绑定到函数调用的this
* 如果函数没有返回其他对戏那个，new表达是肿的函数调用会自动返回这个新对象


### 优先级

**判断this所绑定的对象的常见四条规则**

* 是否在new中调用 如果是，则绑定新创建的对象
* 是否通过call，apply显示绑定，如果是，则绑定指定对象
* 是否在某个上下文对象中调用（隐式绑定），如果是，绑定上下文对象
* 如果都不是 则使用默认绑定，在严格模式下，绑定到undefined，否则绑定到全局对象

### 特殊情况

* 忽略的情况
* apply，call应用null或undefined，会应用默认绑定规则
* 当需要传入一个this绑定对象，但需要一个占位符，需要给出一个比null更空的字符（说明希望这里的this为空的字符）	
* 间接引用
* 软绑定 softbind（），使用方法类似于bind，但是可以多次调整函数this绑定的对象

### ES6 尖头函数

使用胖尖头的操作符定义，不实用四种标准规则，根据外层（函数或全局）作用域来决定this
**箭头函数的绑定无法被修改**

* 常用于回调函数中，例如事件处理器或者定时器

意图替代首先使用```self=this```的写法

如果常用this的话需要注意

* 指采用词法作用域并完全抛弃错误this风格的代码
* 完全采用this风格，必要时使用bind，避免使用self和箭头函数 
