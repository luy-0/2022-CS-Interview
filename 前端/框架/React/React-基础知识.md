# 乱七八糟的概念
- 纯函数：不对传入的形参进行修改
 
> 本文引用（复制）了大量React官方文档，这里只是为了验证和整理自己现在获得的知识，观察是否有漏的知识点，深入了解一些概念
> 闲下来重新看一遍React文档，对之前对React的了解进行再次整理
# 前置知识
- JS
# 核心概念
## JSX
- 直球：JSX就是在JS中写html
## 元素渲染
### 组件
> **组件的名称开头必须大写，表示自定义的组件，和html本身的组件进行区分**
- 组件分为函数组件，class组件，Hooks
    - 函数式组件：获得props，也就是标签中传入的值
    - class组件也会从标签中获得
    - 传入的参数，均从标签传入，所以 我们无法改变上面的标签，所以 **数据单向流动**
- 但是无论哪个组件，在渲染的时候都使用标签
- props具有只读性，组件在运行过程中不能对props做任何更改

## State 
- 相当于React中每个组件适配的变量，但是他能够感知变化并且在之后对组件的视图进行重新的渲染
- 而感知变化的这个过程是通过**setState**进行的
- 所以对State的更改就必须通过setState，否则，state无法感知变化，同时无法重新渲染
- 同时，对数组类型的state进行修改的时候，需要截取和筛选的时候，使用```slice```和```filter```的方法
- 当是对象的时候，使用深拷贝的方法
- state的**更新可能是异步的**，setState将要修改的状态放入一个队列，React会优化真正的执行时机，可能会将多次修改合并为一次

> **数据为什么是单向流动**的：因为数据的传递是从父组件的props传递的，同时，React禁止更改props，所以下面的组件无法更新上面的组件。

> 同时，也因为state是只属于当前组件的属性，无法被其他组件更改，所以对其他组件来说，也是只读的，只能向下传递

## 生命周期
- mount：挂载，组件第一次被渲染到DOM中的时候
- unmount：卸载，组件被删除的时候，清除

# Hooks
## 哲学

## useState

## useEffect
## useCallback
- 传入回调函数和依赖项，当某个依赖项改变时，调用回调函数进行相应操作
- ```useCallback(fn,deps)``` 相当于 ```useMemo(() => fn,deps)```
- 
## useRef
- 返回一个可变的ref对象，其.current属性被初始化为传入的参数
# 高级/更多的优化体验
## 代码分割
- 使webpack能够辨识哪些块是必要的，对必要的库和组件进行打包，从而节省资源
- 也就是只引用一部分代码
- ```js
   import { a } from './compontent' 
   ```

# 参考资料
[React官方文档](https://zh-hans.reactjs.org/docs/components-and-props.html)


