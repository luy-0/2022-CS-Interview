Cyclic Redundancy Check （循环冗余检测）是目前广泛使用的差错检测技术。它能够。由于计算CRC码的过程涉及到二进制下的多项式算数，又被称作多项式编码。

考虑以下二进制运算：
1. 加法。二进制加法不进位，1001 + 1011 = 0010
2. 减法。二进制减法不借位，1001 - 1011 = 0010
3. 在二进制下，加减法是等效的。它们还等效于按位异或。
4. 二进制的乘除法是根据二进制加减法运算的。

## 如何编码
1. 对于`d`比特的原始数据`D`：人为地选定一个长度为`r+1`比特的数据，我们称之为生成多项式`G`（如何选择稍后涉及）；
2. 令`D`左移`r`位，这一步相当于`D*(2^r)`，记为`D'`
3. 对 `D'` 用 `G` 进行二进制除法，所得余数记为`R`（`r`位）
4. `D' +R` 记为编码后的CRC编码

注：`D'` 除以`G` 所得余数`R`。理论上应该是 `D' = n*G + R` 。但是考虑到是二进制下的运算，所以也有 `D' + R = n*G`. 
因此也有 `D'` XOR `R` = `n*G` 。 因此最终得到的CRC码是G的整数倍。

## 解码
想要拿到原有的数据D是简单的，只要取CRC的前d位即可。但是如何保证这些数据是正确的呢？
如果是正常的CRC码（没有出现差错），那么CRC应当是G的整数倍。在接受方将CRC整除G，如果余数为0，表示码值正确。
如果余数不为0，可以进行纠错操作。

## 纠错
如果有1位出错，则余数不为0.

并且不同位出错，余数也不同。可证，余数与出错位的对应关系仅取决于生成多项式G。也就是说，如果我们选择确定的`G`，那么无论原始数据是什么，我们都可以给根据余数的值判断是哪一位出错了。



我们来看下面个例子。`G`=1011，`D`=1010. d = 4（D的位数）, r+1 = 4（G的位数）
在编码阶段，我们计算出 1010 / 1011 余 011，所以CRC为1010 011 (d+r = 7位).

![](https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202011/17/CRC%E6%A0%B7%E4%BE%8B.jpg)

我们也不难从图中看出，不同位出错时，余数也是各不相同的。
我们可以通过循环补除的方法找到并纠正这一位数字，具体做法见下。

假设出错的是A3位：
对于错误结果中的第三行，也就是余数为100，我们对其补零，变成了 1000. 我们再次以G除之。得 1000 / G 余数为011. 这恰好是第四行错误。同时，我们对CRC进行循环左移，这样出错位就变成了A4位

对于错误结果中的第四行，也就是余数为011，我们对其补零，变成了 0110. 我们再次以G除之。得 0110 / G 余数为110. 这恰好是第五行错误。同时，我们对CRC进行循环左移，这样出错位就变成了A5位

......
对于错误结果中的第六行，也就是余数为111，我们对其补零，变成了 1110. 我们再次以G除之。得 1110 / G 余数为101. 这恰好是第七行错误。同时，我们对CRC进行循环左移，这样出错位就变成了A7位

这时，我们发现对第七行 余数101补零后，正好整除G，说明找到了出错位，并且我们已经把出错为移动到了A7处，对其取反纠正。

在此前我们对CRC循环左移了4次，所以我们在纠错后还要再循环左移（7-4=3）次，保证数据不变。

CRC码可以检测多位出错，但是否只能纠错一位出错呢？存疑。

## G: 生成多项式
国际标准已经定义了8,12,16和32比特生成多项式G。其中CRC-32 32比特的标准被多种链路级IEEE协议采用。多项式为：
	G_CRC-32 = `1 00000100 11000001 00011101 10110111 `(r+1=33位)
每个CRC标准都可以检测小于r+1比特的突发错误（意味着所有连续的r比特或者更少的差错都可以检测到）。
每个CRC标准也能检测任何奇数个比特差错。

## 参考资料

[计算机网络（原书第7版） : 自顶向下方法](https://book.douban.com/subject/30280001/)

[计算机组成与设计 李伯成/顾新](https://book.douban.com/subject/6003515/)

[crc纠错原理](https://www.xuebuyuan.com/1567838.html)

