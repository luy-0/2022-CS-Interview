

[TOC]

在开始之前，假设已经了解了HTTP的基础知识。

## HTTP的发展史

- HTTP/0.9 - 单行协议
   HTTP于1990年问世，那时候HTTP非常简单：只支持GET方法；没有首部；只能获取纯文本。

- HTTP/1.0 - 搭建协议的框架
   1996年，HTTP正式被作为标准公布，版本为HTTP/1.0。1.0版本增加了首部、状态码、权限、缓存、长连接（默认短连接）等规范，可以说搭建了协议的基本框架。

- HTTP/1.1 - 进一步完善
   1997年，1.1版本接踵而至。1.1版本的重大改进在于默认长连接；强制客户端提供Host首部；管线化；Cache-Control、ETag 等缓存的相关扩展。

- HTTP/2.0 大版本迭代

  2015年，服务端推送 HTTP/2 将<u>请求和响应数据分割为更小的帧，并且它们采用二进制编码</u>，HTTP/2 的通过支持请求与响应的<u>多路复用来减少延迟</u>，通过<u>压缩 HTTP 首部</u>字段将协议开销降至最低，同时增加对<u>请求优先级</u>和<u>服务器端推送</u>的支持。



## 版本的特性、问题与改进

### 0.9协议

HTTP 是基于 TCP/IP 协议的应用层协议。**它不涉及数据包（packet）传输**，主要规定了客户端和服务器之间的通信格式，默认使用 80 端口。 最早版本是 1991 年发布的 0.9 版。该版本极其简单，只有一个命令 GET。

> GET /index.html

上面命令表示，**TCP 连接（connection）建立后**，客户端向服务器请求（request）网页 index.html。协议规定，服务器只能回应 HTML 格式的字符串，不能回应别的格式。

```
<html>
  <body>Hello World</body>
</html>
复制代码
```

服务器发送完毕，就关闭 TCP 连接。

### 1.0协议

这个版本是最初发行的标准版。相比于0.9，它新增了以下特性

- 首先，**任何格式的内容都可以发送**。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。
- 其次，除了 GET 命令，还引入了 **POST 命令和 HEAD 命令**，丰富了浏览器与服务器的互动手段。
- 再次，HTTP 请求和回应的格式也变了。除了数据部分，**每次通信都必须包括头信息（HTTP header）**，用来描述一些元数据。
- 其他的新增功能还包括**状态码**（status code）、**多字符集支持**、**多部分发送**（multi-part type）、**权限**（authorization）、**缓存**（cache）、**内容编码**（content encoding）等。

但是1.0版本也存在着许多问题，特别是：

- 每个 TCP 连接只能发送一个HTTP请求，而TCP的建立成本是众所周知地高(握手+挥手)

因此半年后，1.1版本发行了。

### 1.1协议

相对于 HTTP/1.0 版本 HTTP/1.1 做了一些优化大致如下：

- **长连接 & 流水线：** HTTP 1.1 支持长连接（Persistent Connection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection： keep-alive。
- **缓存处理：**HTTP1.1 则引入了更多的缓存控制策略（各种缓存头）来控制缓存策略。
- **带宽优化及网络连接的使用**，HTTP1.1 则在请求头引入了range 头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- **错误通知的管理**，在 HTTP1.1 中新增了**24 个错误状态响应码**。
- **Host 头处理**，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都**强制支持** Host 头域，如果没有 Host 头域会报告一个错误（400 Bad Request）。

但是1.1 的问题也有：

- 线头阻塞：TCP连接上只能发送一个请求，前面的请求未完成前，后续的请求都在排队等待。

- 多个TCP连接
   虽然HTTP/1.1管线化可以支持请求并发，但是浏览器很难实现，chrome、firefox等都禁用了管线化。所以1.1版本请求并发依赖于多个TCP连接，建立TCP连接成本很高，还会存在慢启动的问题。

- 头部冗余，采用文本格式
   HTTP/1.X版本是采用文本格式，首部未压缩，而且每一个请求都会带上cookie、user-agent等完全相同的首部。

- 客户端需要主动请求
- 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。

## 2.0新特性

来一个demo感受一下吊炸天的HTTP/2.0，这个demo是加载379张图片，来对比HTTP/1.1和HTTP/2.0的性能。 [HTTP/1.1 与2.0 性能比较](https://http2.akamai.com/demo)



### 二进制分侦层

关键词有两个：

- 二进制：HTTP/2 采用了二进制格式传输数据而不是1.x的文本格式
- 分侦：将每个请求和响应分割成为更小的帧。其中，HTTP1.X中的首部信息header封装到Headers帧中，而request body将被封装到Data帧中。消息由一或多个帧组成，这些帧可以乱序发送，然后根据每个帧首部的流标识符重新组装。
  - 帧：HTTP2.0通信的最小单位，所有帧都共享一个8字节的首部，其中包含帧的长度、类型、标志、还有一个保留位，并且至少有标识出当前帧所属的流的标识符，帧承载着特定类型的数据，如HTTP首部、负荷、等等。
  - 消息：比帧大的通讯单位，是指逻辑上的HTTP消息，比如请求、响应等。由一个或多个帧组成，他们必须在同一个流上。
  - 流：比消息大的通讯单位。是TCP连接中的一个虚拟通道，可以承载双向的消息。每个流都有一个唯一的整数标识符

![](https://user-gold-cdn.xitu.io/2018/12/9/16792b2d88c55af5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

二进制分帧主要是<u>为下文中的各种特性提供了基础。它能把一个数据划分封装为更小更便捷的数据</u>。

首先是在单链接多资源方式中，减少了服务端的链接压力，内存占用更少，链接吞吐量更大。这一点可以结合下文中的多路复用来体会。

另一方面，由于**TCP链接的减少**而使网络拥塞状态得以改善，同时慢启动时间的减少。使拥塞和丢包恢复的速度更快。

### 请求优先级

把HTTP消息分为很多独立帧之后，可以通过优化这些帧的交错和传输顺序，每个流都可以带有一个 31 比特的优先值：0 表示最高优先级；2 的 31 次方-1 表示最低优先级。

客户端明确指定优先级，服务端可以根据这个优先级作为交互数据的依据，比如客户端优先设置为.css>.js>.jpg。服务端按此顺序返回结果更加有利于高效利用底层连接，提高用户体验。

浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不用排队了，既节省了时间，又最大限度的利用了每个连接。



### 多路复用

基于二进制分帧层，HTTP2.0可以在共享TCP链接的基础上同时发送请求和响应。HTTP消息被分解为独立的帧，而不破坏消息本身的语义，交错发出去，在另一端根据流标识符和首部将他们重组起来，形成一个完整的请求或响应。这使得所有的请求或响应都无法阻塞。

多路复用的优势有：

1. 可以并行交错的发送请求和响应，这些请求和响应之间互不影响
2. 只使用一个链接即可并行发送多个请求和响应
3. 消除不必要的延迟，从而减少页面加载的时间
4. 不必再为绕过HTTP1.x限制而多做很多工作



### 头部压缩

在1.X版本中，首部用文本格式传输，通常会给每个传输增加500-800字节的开销。现在打开一个网页上百个请求已是常态，而每个请求带的一些首部字段都是相同的，例如cookie、user-agent等。HTTP2为此采用HPACK压缩格式来压缩首部。

头部压缩需要在浏览器和服务器端之间：

- 维护一份相同的静态字典，包含常见的头部名称，以及常见的头部名称和值的组合
- 维护一份相同的动态字典，可以动态的添加内容
- 通过静态Huffman编码对传输的首部字段进行编码

![](https://user-gold-cdn.xitu.io/2018/1/5/160c570596a277bf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

首部压缩能够<u>使报头更紧凑，更快速传输，有利于移动网络环境。减少每次通讯的数据量，使网络拥塞状态得以改善。</u>

### 服务器端推送

服务器端针对客户端的一个请求， 可以预测它所需要的多个资源，并且返回多个响应。（而不是之前的要一次给一次）。服务器向客户端推送资源无需客户端明确的请求。

 例如：客户端请求index.html，服务器端能够额外推送script.js和style.css。 实现原理就是客户端发出页面请求时，服务器端能够分析这个页面所依赖的其他资源，主动推送到客户端的缓存。当客户端收到原始网页的请求时，它需要的资源已经位于缓存。

针对每一个希望发送的资源，服务器会发送一个PUSH_PROMISE帧，客户端可以通过发送RST_STREAM帧来拒绝推送（当资源已经位于缓存）。这一步的操作先于父响应（index.html），客户端了解到服务器端打算推送哪些资源，就不会再为这些资源创建重复请求。当客户端收到index.html的响应时，script.js和style.css已经位于缓存。

这样不但减轻了数据传送冗余步骤，也加快了页面响应的速度，提高了用户体验。



## 参考资料

[Http系列(一) Http发展历史](https://juejin.im/post/6844903935640240136#heading-6)

[面试官问：你了解HTTP2.0吗？](https://juejin.im/post/6844903734670000142#heading-5)

[HTTP----HTTP2.0新特性](https://juejin.im/post/6844903545532071943)

[HTTP/2 简介](https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn)