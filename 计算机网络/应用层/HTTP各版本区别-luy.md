

[TOC]

在开始之前，假设已经了解了HTTP的基础知识。

## HTTP的发展史

- HTTP/0.9 - 单行协议
   HTTP于1990年问世，那时候HTTP非常简单：只支持GET方法；没有首部；只能获取纯文本。

- HTTP/1.0 - 搭建协议的框架
   1996年，HTTP正式被作为标准公布，版本为HTTP/1.0。

   1.0版本增加了**<u>首部、状态码、权限、缓存、长连接（默认短连接）</u>**等规范，可以说搭建了协议的基本框架。
   
- HTTP/1.1 - 进一步完善
   1997年，1.1版本接踵而至。1.1版本的重大改进在于<u>**默认长连接**</u>；强制客户端提供Host首部；管线化；**<u>Cache-Control、ETag 等缓存</u>**的相关扩展。

- HTTP/2.0 大版本迭代

  2015年，服务端推送 HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用<u>二进制编码</u>，HTTP/2 的通过支持请求与响应的多路复用来减少延迟，通过压缩 HTTP 首部字段将协议开销降至最低，同时增加对请求优先级和服务器端推送的支持。





## 0.9协议

HTTP 是基于 TCP/IP 协议的应用层协议。<u>它不涉及数据包（packet）传输</u>，主要规定了客户端和服务器之间的通信格式，默认使用 80 端口。 最早版本是 1991 年发布的 0.9 版。该版本极其简单，<u>只有一个命令 GET</u>。

> GET /index.html

上面命令表示，**TCP 连接（connection）建立后**，客户端向服务器请求（request）网页 index.html。协议规定，服务器只能回应 HTML 格式的字符串，不能回应别的格式。

```
<html>
  <body>Hello World</body>
</html>

```

服务器发送完毕，就关闭 TCP 连接。



## 1.0协议

这个版本是最初发行的标准版。相比于0.9，它新增了以下特性

- 首先，**任何格式的内容都可以发送**。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。这取决于 <u>`Content-Type` 头部</u>。
- 其次，除了 GET 命令，还引入了 **POST 命令和 HEAD 命令**，丰富了浏览器与服务器的互动手段。
- 再次，不论是请求还是回应，**每次通信都必须包括头信息（HTTP header）**，也就是将控制逻辑与数据部分进行了分离。
- 其他的新增功能还包括**状态码**（status code）、**多字符集支持**、**多部分发送**（multi-part type）、**权限**（authorization）、**缓存**（cache）、**内容编码**（content encoding）等。

> 注：在 HTTP 1.0 中, 没有官方的 keepalive 的操作。但是可以在协议中额外增加指数来提供；1.1版本提供了官方默认长连接。

HTTP 1.0 开始让这个协议变得很文明了，一种工程文明。因为：

- 一个协议有没有版本管理，是一个工程化的象征。
- header是协议可以说是把元数据和业务数据解耦，也可以说是控制逻辑和业务逻辑的分离。
- Status Code 的出现可以让请求双方以及第三方的监控或管理程序有了统一的认识。最关键是还是控制错误和业务错误的分离。

但是1.0版本也存在着许多问题，特别是：

- 每请求一个资源都要新建一个TCP链接，而且是串行请求，而TCP的建立成本是众所周知地高(握手+挥手)

因此半年后，1.1版本发行了。



## 1.1协议

相对于 HTTP/1.0 版本 HTTP/1.1 做了一些优化大致如下：

- **长连接**：最重要的就是，可以设置 `keepalive` 来让HTTP重用TCP链接，重用TCP链接可以省了每次请求都要在广域网上进行的TCP的三次握手的巨大开销。这是所谓的“**<u>HTTP 长链接</u>**” 或是 “**请求响应式的HTTP 持久链接**”。英文叫 HTTP Persistent connection.
- **流水线：** 支持**<u>pipeline网络传输</u>**，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。（注：非幂等的POST 方法或是有依赖的请求是不能被pipeline化的）
- **缓存处理：**HTTP1.1 则引入了更多的缓存控制策略（各种缓存头）来控制缓存策略。
- **带宽优化及网络连接的使用**，HTTP1.1 则在请求头引入了range 头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- **错误通知的管理**，在 HTTP1.1 中新增了**24 个错误状态响应码**。
- 支持 Chunked Responses ，也就是说，在Response的时候，不必说明 `Content-Length` 这样，客户端就不能断连接，直到收到服务端的EOF标识。这种技术又叫 “**服务端Push模型**”，或是 “**服务端Push式的HTTP 持久链接**”
- **Host 头处理**，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都**强制支持** Host 头域，如果没有 Host 头域会报告一个错误（400 Bad Request）。



在 2014 年后，HTTP/1.1有了一组RFC（[7230](https://tools.ietf.org/html/rfc7230) /[7231](https://tools.ietf.org/html/rfc7231)/[7232](https://tools.ietf.org/html/rfc7232)/[7233](https://tools.ietf.org/html/rfc7233)/[7234](https://tools.ietf.org/html/rfc7234)/[7235](https://tools.ietf.org/html/rfc7235)），这组RFC又叫“HTTP/2 预览版”。其中影响HTTP发展的是两个大的需求：
一个需要是加大了HTTP的安全性，这样就可以让HTTP应用得广泛，比如，使用TLS协议。

另一个是让HTTP可以支持更多的应用，在HTTP/1.1 下，HTTP已经支持四种网络协议：

- 传统的短链接。
- 可重用TCP的的长链接模型。
- 服务端push的模型。
- WebSocket模型。

自此，这个世界基本的应用协议的标准基本上都是向HTTP看齐了



但是1.1 的问题也有：

- 串行阻塞

   可以重用TCP链接，但是请求还是一个一个串行发的，需要保证其顺序。TCP连接上只能发送一个请求，前面的请求未完成前，后续的请求都在排队等待。

- 多个TCP连接
   虽然HTTP/1.1管线化可以支持请求并发，但是浏览器很难实现，chrome、firefox等都禁用了管线化。所以1.1版本请求并发依赖于多个TCP连接，建立TCP连接成本很高，还会存在慢启动的问题。

- 头部冗余，采用文本格式
   HTTP/1.X版本是采用文本格式，首部未压缩，而且每一个请求都会带上cookie、user-agent等完全相同的首部。

- 客户端需要主动请求

- 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。

## 2.0协议

来一个demo感受一下吊炸天的HTTP/2.0，这个demo是加载379张图片，来对比HTTP/1.1和HTTP/2.0的性能。 [HTTP/1.1 与2.0 性能比较](https://http2.akamai.com/demo)



- HTTP/2是一个二进制协议，增加了数据传输的效率。
- HTTP/2是可以在一个TCP链接中并发请求多个HTTP请求，移除了HTTP/1.1中的串行请求。
- HTTP/2会压缩头，如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。这就是所谓的HPACK算法（参看[RFC 7541](https://tools.ietf.org/html/rfc7541) 附录A）
- HTTP/2允许服务端在客户端放cache，又叫服务端push，也就是说，你没有请求的东西，我服务端可以先送给你放在你的本地缓存中。比如，你请求X，我服务端知道X依赖于Y，虽然你没有的请求Y，但我把把Y跟着X的请求一起返回客户端。



### 二进制分侦层

关键词有两个：

- 二进制：HTTP/2 采用了二进制格式传输数据而不是1.x的文本格式
- 分侦：将每个请求和响应分割成为更小的帧。其中，HTTP1.X中的首部信息header封装到Headers帧中，而request body将被封装到Data帧中。消息由一或多个帧组成，这些帧可以乱序发送，然后根据每个帧首部的流标识符重新组装。
  - 帧：HTTP2.0通信的最小单位，所有帧都共享一个8字节的首部，其中包含帧的长度、类型、标志、还有一个保留位，并且至少有标识出当前帧所属的流的标识符，帧承载着特定类型的数据，如HTTP首部、负荷、等等。
  - 消息：比帧大的通讯单位，是指逻辑上的HTTP消息，比如请求、响应等。由一个或多个帧组成，他们必须在同一个流上。
  - 流：比消息大的通讯单位。是TCP连接中的一个虚拟通道，可以承载双向的消息。每个流都有一个唯一的整数标识符

![](https://user-gold-cdn.xitu.io/2018/12/9/16792b2d88c55af5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

二进制分帧主要是<u>为下文中的各种特性提供了基础。它能把一个数据划分封装为更小更便捷的数据</u>。

首先是在单链接多资源方式中，减少了服务端的链接压力，内存占用更少，链接吞吐量更大。这一点可以结合下文中的多路复用来体会。

另一方面，由于**TCP链接的减少**而使网络拥塞状态得以改善，同时慢启动时间的减少。使拥塞和丢包恢复的速度更快。



### 多路复用

基于二进制分帧层，HTTP2.0可以在共享TCP链接的基础上同时发送请求和响应。HTTP消息被分解为独立的帧，而不破坏消息本身的语义，交错发出去，在另一端根据流标识符和首部将他们重组起来，形成一个完整的请求或响应。这使得所有的请求或响应都无法阻塞。

多路复用的优势有：

1. 可以并行交错的发送请求和响应，这些请求和响应之间互不影响
2. 只使用一个链接即可并行发送多个请求和响应
3. 消除不必要的延迟，从而减少页面加载的时间
4. 不必再为绕过HTTP1.x限制而多做很多工作



### 头部压缩

在1.X版本中，首部用文本格式传输，通常会给每个传输增加500-800字节的开销。现在打开一个网页上百个请求已是常态，而每个请求带的一些首部字段都是相同的，例如cookie、user-agent等。HTTP2为此采用HPACK压缩格式来压缩首部。

头部压缩需要在浏览器和服务器端之间：

- 维护一份相同的静态字典，包含常见的头部名称，以及常见的头部名称和值的组合
- 维护一份相同的动态字典，可以动态的添加内容
- 通过静态Huffman编码对传输的首部字段进行编码

![](https://user-gold-cdn.xitu.io/2018/1/5/160c570596a277bf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

首部压缩能够<u>使报头更紧凑，更快速传输，有利于移动网络环境。减少每次通讯的数据量，使网络拥塞状态得以改善。</u>

### 服务器端推送

服务器端针对客户端的一个请求， 可以预测它所需要的多个资源，并且返回多个响应。（而不是之前的要一次给一次）。服务器向客户端推送资源无需客户端明确的请求。

 例如：客户端请求index.html，服务器端能够额外推送script.js和style.css。 实现原理就是客户端发出页面请求时，服务器端能够分析这个页面所依赖的其他资源，主动推送到客户端的缓存。当客户端收到原始网页的请求时，它需要的资源已经位于缓存。

针对每一个希望发送的资源，服务器会发送一个PUSH_PROMISE帧，客户端可以通过发送RST_STREAM帧来拒绝推送（当资源已经位于缓存）。这一步的操作先于父响应（index.html），客户端了解到服务器端打算推送哪些资源，就不会再为这些资源创建重复请求。当客户端收到index.html的响应时，script.js和style.css已经位于缓存。

这样不但减轻了数据传送冗余步骤，也加快了页面响应的速度，提高了用户体验。



### 请求优先级

把HTTP消息分为很多独立帧之后，可以通过优化这些帧的交错和传输顺序，每个流都可以带有一个 31 比特的优先值：0 表示最高优先级；2 的 31 次方-1 表示最低优先级。

客户端明确指定优先级，服务端可以根据这个优先级作为交互数据的依据，比如客户端优先设置为.css>.js>.jpg。服务端按此顺序返回结果更加有利于高效利用底层连接，提高用户体验。

浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不用排队了，既节省了时间，又最大限度的利用了每个连接。









## 参考资料

[Http系列(一) Http发展历史](https://juejin.im/post/6844903935640240136#heading-6)

[面试官问：你了解HTTP2.0吗？](https://juejin.im/post/6844903734670000142#heading-5)

[HTTP----HTTP2.0新特性](https://juejin.im/post/6844903545532071943)

[HTTP/2 简介](https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn)

[HTTP的前世今生](https://coolshell.cn/articles/19840.html)

